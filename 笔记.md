# 项目笔记

## 1.项目目录介绍
api： 存放请求
assets:存放资源
components:存放公共组件
contants: 存放常量文件
viewmodels:存放类型文件
pages：存放页面
routes：存放路由配置
stores:存放全局状态组件
utils：存放工具类
main.dart ： 入口文件 


## 2. 搭建基础路由和组件
应用的路由结构如下：
![alt text](7568d3eb-b325-4560-8392-cb0e7579d2c6.png)

意思是只有两个页面，一个是主页，一个登陆页。至于分类、购物车、我的。只是主页的子组件。

## 3. 实现主页tab栏
![alt text](b3bdecc1-d6a3-411f-aad0-eeec952071e3.png)

底部tab我们是使用BottomNavigationBar去实现，它是可以切换索引的。

然后我们的每一个tab项对应的视图是通过SafeArea包裹IndexedStack组件实现的。IndexedStack组件可以设置索引号。

这样一来，我们点击哪个tab，就会切换到对应的视图。

## 3. 首页布局
![alt text](01ff56cd-cb4b-4c38-bc9a-d48dde314dcf.png)

新学到的知识点：
1. SliverGrid 和 SliverList 只支持纵向排列。
2. 作为SliverToBoxAdapter的子组件的话，子组件必须指定明确的高度。否则无法显示。

## 4.实现轮播图
本案例的轮播图，我们不采用PageView组件，因为PageView组件功能太单一了。我们使用第三方轮播图插件，所以我们需要安装一下：
flutter pub add carousel_slider

并且准备了几张供测试使用的网络图片，如下：
https://yiy-teach-oss.oss-cn-beijing.aliyuncs.com/meituan/1.jpg
https://yiy-teach-oss.oss-cn-beijing.aliyuncs.com/meituan/2.jpg
https://yiy-teach-oss.oss-cn-beijing.aliyuncs.com/meituan/3.jpg

学到的新知识：
1. 因为我们的轮播图数据可能是通过网络请求获取的，所以我们请求之后我们必须要知道用什么数据类型去接收这份接口返回的数据，所以我们需要在viewmodels中新建一个home.dart文件去定义类型。
你可能会说，之前第二阶段学习的时候，我们不是使用Map<String,dynamic>去接收接口返回的数据吗？
当然这样是可以的，但是如果你需要更明确的类型，那么你就需要定义一个类型。

## 5. 实现轮播图上面的搜索框和轮播图指示点
注意，我们这个应用中，搜索框我们只实现它的样式即可，不实现它的功能。

学到的新知识：
如果我们有一个Container组件，Container组件里面的某些样式是要在运行时通过三元表达式去判断而决定取值的，那么我们如果要为样式的变化设置一个动画效果的话，我们就需要使用AnimatedContainer组件。只需要指定一个动画时间，就直接实现了动画效果。十分的方便。

## 6.获取轮播图数据
我们要实现以下步骤：
1. 安装dio插件
2. 定义常量数据、基础地址、超时时间、业务状态、请求地址
3. 封装网络请求工具、基础地址、拦截器。
4. 请求工具进一步解构，处理http状态和业务状态
5. 类工厂转化动态类型到对象类型
6. 封装请求API调用工厂函数
7. 初始化数据更新状态

## 7.获取分类数据并渲染
和上节课的方式一样，定义接口地址常量，定义分类数据类型，定义分类数据请求工厂函数。然后渲染分类数据。


## 8.获取特惠推荐数据并渲染
这节课的重点在于特惠推荐数据类型转换工厂函数的实现。复习时可以看看。

新知识：
ClipRRect 组件可以实现图片圆角裁剪效果。

## 9.获取爆款推荐和一战全面数据并渲染
新知识：
  // 取前2条
  List<Goods> get _items {
    if (widget.specialOffers.subTypes.isEmpty) return [];
    return widget.specialOffers.subTypes.first.goodsItems.first.items
        .take(2)
        .toList();
  }
这个写法 就是 flutter中的计算属性。

## 10.获取推荐列表的数据并渲染
新知识 + 新理解：
class Goods {
  String id;
  String name;
  String desc;
  String price;
  String picture;
  int orderNum;
  Goods({
    required this.id,
    required this.name,
    required this.desc,
    required this.price,
    required this.picture,
    required this.orderNum,
  });
  factory Goods.fromJSON(Map<String, dynamic> json) {
    return Goods(
      id: json['id'] ?? '',
      name: json['name'] ?? '',
      desc: json['desc'] ?? '',
      price: json['price'] ?? '',
      picture: json['picture'] ?? '',
      orderNum: json['orderNum'] ?? 0,
    );
  }
}

class GoodDetailItem extends Goods {
  int payCount = 0;
  GoodDetailItem({
    required super.id,
    required super.name,
    required super.price,
    required super.picture,
    required super.orderNum,
    required this.payCount,
  }):super(desc: '');
  factory GoodDetailItem.fromJSON(Map<String, dynamic> json) {
    return GoodDetailItem(
      id: json['id'] ?? '',
      name: json['name'] ?? '',
      price: json['price'] ?? '',
      picture: json['picture'] ?? '',
      orderNum: json['orderNum'] ?? 0,
      payCount: json['payCount'] ?? 0,
    );
  }
}

你知道为什么在dart中，子类继承父类的时候，一定要先进行父类的实例化(初始化)，然后再进行子类的实例化吗？
比如上面这个例子，GoodDetailItem 继承了 Goods 类，所以我们都知道父类的所有属性和方法子类都会有，那么我们子类就不用再次去定义父类中存在的这些属性了，我们对这些父类已经存在的属性我们只需要去在子类的构造函数中去接收它们，然后传递给父类的构造函数即可，然后父类的构造函数执行完成后，相当于父类进行了实例化了，那么父类中的各种属性就都有值了，那么也就相当于子类继承的这些父类的属性也就都有值了，而父类的就是子类的，也就是相当于子类的这些属性都是有值了的。

上述代码的语法解析：
  GoodDetailItem({
    required super.id,
    required super.name,
    required super.price,
    required super.picture,
    required super.orderNum,
    required this.payCount,
  }):super(desc: '');

其实就相当于
GoodDetailItem({
  required String id,    // 子类先接收参数
  required String name,
  required String price,
  required String picture,
  required int orderNum,
  required this.payCount, // 注意： 这个就是子类实例自己特有的属性
}):super(               // 手动传给父类
  id: id,               // 把子类接收的 id 传给父类的 id
  name: name,
  price: price,
  picture: picture,
  orderNum: orderNum,
  desc: ''
);

总结的意思*（关于dart中的继承，十分重要的理解）：
首先会进行父类的实例化，然后再进行子类的实例化。 子类实例化时，子类的构造函数是只给自己独有的属性赋值的。然后子类自身的实例对象只有自己的属性，其他属性全部继承自父类，因为父类在子类实例化之前就完成了实例化。此时的子类的实例化对象就既有了自己独有的属性，也有了父类的属性。从而完成了继承。

在子类的构造函数中属性required String name, 这种写法就是单纯的在接收参数，而required this.payCount,这种写法则是在给子类实例自己特有的属性赋值。

你发现没有，dart中的继承和js中的继承是不一样的，js中的继承是借用父类构造函数的方式，在子类调用父类的构造函数时，this指向子类实例本身！！！而dart中，子类调用父类的构造函数，构造函数内部this指向依旧还是父类的实例化对象，子类的调用自身的构造函数内部this指向也是子类本身。 然后父类实例化对象上的属性和方法子类可以直接访问，相当于自己的，从而实现了继承。


## 11. 实现了推荐列表上拉加载
这一节没有什么新知识。


## 12. 实现了下拉刷新/封装提示消息/GlobakKey
这节课实现了首页的整体id下拉刷新
刷新之后的提示消息，我们封装成了一个公共组件，方便使用
GlobalKey实际上就是Vue 和 React 中的ref引用，我们可以通过它来触发组件实例上的方法。但注意initState钩子中是无法直接获取到该ref的，因为此时build并未执行，所以我们要把调用ref的方法代码用Future.micotask来包裹变成一个微任务，等到build执行完成后再执行该代码，就能成功拿到该ref了。